using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using MineSharp.PacketSourceGenerator.Utils;

namespace MineSharp.PacketSourceGenerator.Generators;

public abstract class AbstractPacketGenerator
{
	#region Constants

	protected const string InheritDocComment = "/// <inheritdoc/>";

	#endregion

	private static string BuildGeneratedCodeAttributeDeclaration(string attributeTypeName)
	{
		return $"[{attributeTypeName}(\"{SourceGenerator.SourceGeneratorName}\", \"{SourceGenerator.SourceGeneratorVersionString}\")]";
	}

	public readonly GeneratorArguments Args;
	protected readonly HashSet<ImportItem> Imports = new();

	protected AbstractPacketGenerator(GeneratorArguments args)
	{
		Args = args;
	}

	protected string GeneratedCodeAttributeDeclaration => BuildGeneratedCodeAttributeDeclaration(BuildTypeName(Args.CommonSymbolHolder.GeneratedCodeAttribute));

	public abstract string? BuildBodyForType();

	public virtual string? GenerateFileSource()
	{
		return BuildFileSource();
	}

	public virtual GeneratedSourceFileInfo? GenerateFile()
	{
		var source = BuildFileSource();
		if (source is null)
		{
			return null;
		}

		var fileName = GeneratedSourceFileInfo.BuildFileName(Args.TypeSymbol);
		return new GeneratedSourceFileInfo(fileName, source);
	}

	private string? BuildFileSource(bool includeSelf = false)
	{
		var result = BuildBodyForType();
		if (result is null)
		{
			return null;
		}

		var containingSymbols = Args.TypeSymbol.GetContainingNamespaceAndTypes(includeSelf);
		foreach (var symbol in containingSymbols)
		{
			if (symbol.IsNamespace)
			{
				var namespaceName = symbol.ToDisplayString(SymbolHelper.FullyQualifiedFormatWithoutGlobalPrefix);

				var importsStr = BuildImports();
				if (!string.IsNullOrEmpty(importsStr))
				{
					importsStr += Args.GeneratorOptions.NewLine;
				}

				var newResult = $$"""
					{{GeneratorHelper.AutoGeneratedSourceFileHeader}}

					{{importsStr ?? ""}}
					""";

				if (!string.IsNullOrEmpty(namespaceName))
				{
					newResult += $$"""
						namespace {{namespaceName}}
						{
							{{result.IndentLines(indentString: Args.GeneratorOptions.Indent, ignoreFirstLine: true)}}
						}
						""";
				}
				else
				{
					newResult += result;
				}

				result = newResult;
			}
			else
			{
				var keyword = ((INamedTypeSymbol)symbol).GetTypeKeywordFromSymbol();

				var minimalTypeName = symbol.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat);
				result = $$"""
					partial {{keyword}} {{minimalTypeName}}
					{
						{{result.IndentLines(indentString: Args.GeneratorOptions.Indent, ignoreFirstLine: true)}}
					}
					""";
			}
		}

		return result;
	}

	protected string BuildTypeSource(IReadOnlyCollection<string> methods, string extendsString = "")
	{
		var keyword = Args.TypeSymbol.GetTypeKeywordFromSymbol();

		var minimalTypeName = Args.TypeSymbol.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat);
		return $$"""
			partial {{keyword}} {{minimalTypeName}}{{extendsString}}
			{
				{{methods.Join(Args.GeneratorOptions.NewLine.Repeat(2)).IndentLines(indentString: Args.GeneratorOptions.Indent, ignoreFirstLine: true)}}
			}
			""";
	}

	#region Methods

	protected string BuildPacketReadMethod(IMethodSymbol interfaceMethodToImplement)
	{
		var interfaceTypeString = BuildTypeName(interfaceMethodToImplement.ContainingType);
		var interfaceMethodName = interfaceMethodToImplement.Name;
		var returnTypeString = BuildTypeName(interfaceMethodToImplement.ReturnType);

		// sanity check that the method has the correct signature
		if (!interfaceMethodToImplement.IsStatic)
		{
			throw new InvalidOperationException("Read method must be static.");
		}
		if (interfaceMethodToImplement.Parameters.Length != 2)
		{
			throw new InvalidOperationException("Read method must have exactly 2 parameters.");
		}
		var packetBufferType = Args.CommonSymbolHolder.PacketBuffer;
		var minecraftDataType = Args.CommonSymbolHolder.MinecraftData;
		if (!interfaceMethodToImplement.Parameters.Select(p => p.Type).SequenceEqual([packetBufferType, minecraftDataType], SymbolEqualityComparer.Default))
		{
			throw new InvalidOperationException($"First parameter of Read method must be of type {packetBufferType.Name} and the second must be of type {minecraftDataType.Name}.");
		}
		var packetBufferTypeString = BuildTypeName(packetBufferType);
		var minecraftDataTypeString = BuildTypeName(minecraftDataType);

		return $$"""
			{{GeneratedCodeAttributeDeclaration}}
			static {{returnTypeString}} {{interfaceTypeString}}.{{interfaceMethodName}}({{packetBufferTypeString}} buffer, {{minecraftDataTypeString}} data)
			{
			    return Read(buffer, data);
			}
			""";
	}

	#endregion

	#region Imports

	private string? BuildImports()
	{
		var sb = new StringBuilder();

		foreach (var import in Imports.OrderBy(x => x))
		{
			sb.Append(import.ToString());
			sb.Append(Args.GeneratorOptions.NewLine);
		}

		if (sb.Length == 0)
		{
			return null;
		}

		return sb.ToString();
	}

	protected void AddTypeImport(ITypeSymbol typeSymbol)
	{
		var import = typeSymbol.GetFqnPath(addGlobalPrefix: false);
		if (import is not null)
		{
			Imports.Add(import.Value);
		}

		// also add the generic type argument types
		if (typeSymbol is INamedTypeSymbol namedTypeSymbol)
		{
			foreach (var typeParameter in namedTypeSymbol.TypeParameters)
			{
				import = typeParameter.GetFqnPath(addGlobalPrefix: false);
				if (import is not null)
				{
					Imports.Add(import.Value);
				}
			}
		}
	}

	protected string BuildTypeName(ITypeSymbol typeSymbol, bool skipImport = false)
	{
		if (DebugHelper.UseFullyQualifiedNames)
		{
			return typeSymbol.ToFqn();
		}

		var typeName = typeSymbol.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat);
		if (!skipImport)
		{
			AddTypeImport(typeSymbol);
		}
		return typeName;
	}

	#endregion
}
